# README

当前文档主要描述猜测栈节点的算法。

# 问题

我们把一个调用栈表示成一行，每个元素表示一个栈节点，左侧是跟节点，右侧是叶子节点。
那么调用顺序就是左侧调用右侧。因此左侧会相对更稳定，而右侧更多边。

```
Sn: f1, f2, f3, ..., fn

  (root)            (leaf)
```

假设每个栈左侧会有不定个数的连续栈节点被截断，那么栈就没有办法互相对齐了。
我们需要补齐这里面被截断的栈节点，好让各个栈能重新互相对齐。

例如：原始栈

```
S1: f1, f2, f3, f4, f5, f6
S2: f1, f2, f3, f4, f7
```

左侧截断后

```
S1: f3, f4, f5, f6      (截掉了 f1, f2)
S2: f1, f2, f3, f4, f7
```

恢复出来后需要能重新变成

```
S1: f1, f2, f3, f4, f5, f6  (恢复被截掉的 f1, f2)
S2: f1, f2, f3, f4, f7
```

# 分析

如果两个栈根部原本相同，
那么当其中一个栈的部分根部节点被截掉后，他里面剩余的根部节点应该能与另一个栈的中间部分节点重叠。
因此，我们可以通过重叠的位置，猜测他被截掉的根部栈节点是什么。

如：

存在两个栈 `S1` 和 `S2`，`S1` 的根部栈节点 `f3, f4` 与 `S2` 栈中的第3、4个节点重叠。
那么我们猜测 `S2` 中的`f1, f2` 就是`S1`中被截掉的栈节点。

```
S1:   ,   , f3, f4, f5, f6
S2: f1, f2, f3, f4, f7
```

重叠部分越长，那么这种猜测成立的可能性就越大。

# 解决思路

如果栈`S1`的根部与`S2`最长重叠（`MOR`, `max overlapping range`），是从`S2`的第`s`个元素位置（从叶子向根方向统计）开始的，重叠部分长度为`l`。
那么我们将这个记成:

```
MOR(S1, S2) = (s, l) // S1's root overlaps S2, from the s'th-element and ranges with l elements.
```

如果`MOR(S1, S2) = (s, 0)`，那么说明这两个栈节点没有重叠的部分，他们可能没有相同的根。

当存在多个栈时（如：`{S1, S2, S3, ..., Sn}`），对于`Si`，我们能够找到它与任意一个栈`Sj`的最长重叠（`MOR(i, j)`）。
其中，`MOR(i,j)`最长的`j`应该与`i`是具有相同的根的。

| MOR | 1        | 2        | 3        | ... | n        | Possible MOR  |
|-----|----------|----------|----------|-----|----------|---------------|
| 1   | -        | MOR(1,2) | MOR(1,3) | ... | MOR(1,n) | max{MOR(1,k)} |
| 2   | MOR(2,1) | -        | MOR(2,3) | ... | MOR(2,n) | max{MOR(2,k)} |
| 3   | MOR(3,1) | MOR(3,2) | -        | ... | MOR(3,n) | max{MOR(3,k)} |
| ... | ...      | ...      | ...      | ... | ...      | ...           |
| n   | MOR(n,1) | MOR(n,2) | MOR(n,3) | ... | -        | max{MOR(n,k)} |


## 不能循环

这里可以将上述的共享根节点过程理解为构建一颗树。共享根节点的过程即为将一个栈添加到另一个栈的某个节点的子节点列表中。

那么需要保证最终是一棵树，而不应该出现环

![loop.png](../doc/loop.png)

这样的限制总结起来就是：

1. 不应该计算自重叠。一个栈不应该嫁接到自己的某个节点上。
2. 将有嫁接关系的节点归类到一个组中，如果一个组中已经有某个栈嫁接到当前栈，那么当前栈就不应该再嫁接到该组中的任意一个栈上。

## 动态计算`MOR`

假设`MOR(i,j) = (s,l)`是对栈`Si`根节点的最佳猜测，那么栈`i`的节点就需要更新。一旦更新了，那么其他的栈对`Si`的`MOR`可能都需要重新计算。